/*
================================================================================
CDC PIPELINE MONITORING AND OBSERVABILITY FRAMEWORK
================================================================================
Version:        1.0.0
Created:        2026-02-25
Author:         Snowflake CDC Expert
Environment:    D_RAW.SADB -> D_BRONZE.SADB CDC Pipeline

Purpose:        Complete monitoring and observability solution for 20 CDC tables
                - Real-time pipeline health monitoring
                - Stream staleness detection
                - Task execution tracking
                - Data quality metrics
                - Alerting integration
                - Performance analytics

Tables Monitored (20):
    1.  EQPMNT_AAR_BASE               11. TRAIN_CNST_SMRY
    2.  EQPMV_EQPMT_EVENT_TYPE        12. TRAIN_PLAN
    3.  EQPMV_RFEQP_MVMNT_EVENT       13. TRAIN_PLAN_EVENT
    4.  LCMTV_EMIS                    14. TRAIN_PLAN_LEG
    5.  LCMTV_MVMNT_EVENT             15. TRKFCG_FIXED_PLANT_ASSET
    6.  OPTRN                         16. TRKFCG_FXPLA_TRACK_LCTN_DN
    7.  OPTRN_EVENT                   17. TRKFCG_SBDVSN
    8.  OPTRN_LEG                     18. TRKFCG_SRVC_AREA
    9.  STNWYB_MSG_DN                 19. TRKFCG_TRACK_SGMNT_DN
    10. TRAIN_CNST_DTL_RAIL_EQPT      20. TRKFC_TRSTN
================================================================================
*/

-- ============================================================================
-- STEP 1: CREATE MONITORING SCHEMA
-- ============================================================================
CREATE SCHEMA IF NOT EXISTS D_BRONZE.CDC_MONITORING
    COMMENT = 'CDC Pipeline Monitoring and Observability Schema';

-- ============================================================================
-- STEP 2: CREATE MONITORING CONFIGURATION TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG (
    CONFIG_ID NUMBER AUTOINCREMENT PRIMARY KEY,
    TABLE_NAME VARCHAR(100) NOT NULL,
    SOURCE_SCHEMA VARCHAR(100) DEFAULT 'D_RAW.SADB',
    TARGET_SCHEMA VARCHAR(100) DEFAULT 'D_BRONZE.SADB',
    STREAM_NAME VARCHAR(150) NOT NULL,
    PROCEDURE_NAME VARCHAR(150) NOT NULL,
    TASK_NAME VARCHAR(150) NOT NULL,
    PRIMARY_KEY_COLUMNS VARCHAR(500) NOT NULL,
    EXPECTED_COLUMNS NUMBER NOT NULL,
    SCHEDULE_MINUTES NUMBER DEFAULT 5,
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    ALERT_THRESHOLD_MINUTES NUMBER DEFAULT 30,
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    UPDATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    CONSTRAINT UQ_CDC_PIPELINE_CONFIG_TABLE UNIQUE (TABLE_NAME)
);

-- Insert configuration for all 20 tables
INSERT INTO D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG 
    (TABLE_NAME, STREAM_NAME, PROCEDURE_NAME, TASK_NAME, PRIMARY_KEY_COLUMNS, EXPECTED_COLUMNS)
VALUES
    ('EQPMNT_AAR_BASE', 'D_RAW.SADB.EQPMNT_AAR_BASE_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_EQPMNT_AAR_BASE', 'D_RAW.SADB.TASK_PROCESS_EQPMNT_AAR_BASE', 'AAR_BASE_ID', 53),
    ('EQPMV_EQPMT_EVENT_TYPE', 'D_RAW.SADB.EQPMV_EQPMT_EVENT_TYPE_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_EQPMV_EQPMT_EVENT_TYPE', 'D_RAW.SADB.TASK_PROCESS_EQPMV_EQPMT_EVENT_TYPE', 'EQPMT_EVENT_TYPE_ID', 19),
    ('EQPMV_RFEQP_MVMNT_EVENT', 'D_RAW.SADB.EQPMV_RFEQP_MVMNT_EVENT_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_EQPMV_RFEQP_MVMNT_EVENT', 'D_RAW.SADB.TASK_PROCESS_EQPMV_RFEQP_MVMNT_EVENT', 'EVENT_ID', 96),
    ('LCMTV_EMIS', 'D_RAW.SADB.LCMTV_EMIS_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_LCMTV_EMIS', 'D_RAW.SADB.TASK_PROCESS_LCMTV_EMIS', 'EMIS_ID', 48),
    ('LCMTV_MVMNT_EVENT', 'D_RAW.SADB.LCMTV_MVMNT_EVENT_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_LCMTV_MVMNT_EVENT', 'D_RAW.SADB.TASK_PROCESS_LCMTV_MVMNT_EVENT', 'LCMTV_MVMNT_EVENT_ID', 58),
    ('OPTRN', 'D_RAW.SADB.OPTRN_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_OPTRN', 'D_RAW.SADB.TASK_PROCESS_OPTRN', 'OPTRN_ID', 52),
    ('OPTRN_EVENT', 'D_RAW.SADB.OPTRN_EVENT_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_OPTRN_EVENT', 'D_RAW.SADB.TASK_PROCESS_OPTRN_EVENT', 'OPTRN_EVENT_ID', 52),
    ('OPTRN_LEG', 'D_RAW.SADB.OPTRN_LEG_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_OPTRN_LEG', 'D_RAW.SADB.TASK_PROCESS_OPTRN_LEG', 'OPTRN_LEG_ID', 48),
    ('STNWYB_MSG_DN', 'D_RAW.SADB.STNWYB_MSG_DN_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_STNWYB_MSG_DN', 'D_RAW.SADB.TASK_PROCESS_STNWYB_MSG_DN', 'STNWYB_MSG_VRSN_ID', 136),
    ('TRAIN_CNST_DTL_RAIL_EQPT', 'D_RAW.SADB.TRAIN_CNST_DTL_RAIL_EQPT_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRAIN_CNST_DTL_RAIL_EQPT', 'D_RAW.SADB.TASK_PROCESS_TRAIN_CNST_DTL_RAIL_EQPT', 'TRAIN_CNST_SMRY_ID,TRAIN_CNST_SMRY_VRSN_NBR,SQNC_NBR', 83),
    ('TRAIN_CNST_SMRY', 'D_RAW.SADB.TRAIN_CNST_SMRY_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRAIN_CNST_SMRY', 'D_RAW.SADB.TASK_PROCESS_TRAIN_CNST_SMRY', 'TRAIN_CNST_SMRY_ID,TRAIN_CNST_SMRY_VRSN_NBR', 93),
    ('TRAIN_PLAN', 'D_RAW.SADB.TRAIN_PLAN_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRAIN_PLAN', 'D_RAW.SADB.TASK_PROCESS_TRAIN_PLAN', 'TRAIN_PLAN_ID', 49),
    ('TRAIN_PLAN_EVENT', 'D_RAW.SADB.TRAIN_PLAN_EVENT_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRAIN_PLAN_EVENT', 'D_RAW.SADB.TASK_PROCESS_TRAIN_PLAN_EVENT', 'TRAIN_PLAN_EVENT_ID', 45),
    ('TRAIN_PLAN_LEG', 'D_RAW.SADB.TRAIN_PLAN_LEG_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRAIN_PLAN_LEG', 'D_RAW.SADB.TASK_PROCESS_TRAIN_PLAN_LEG', 'TRAIN_PLAN_LEG_ID', 48),
    ('TRKFCG_FIXED_PLANT_ASSET', 'D_RAW.SADB.TRKFCG_FIXED_PLANT_ASSET_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRKFCG_FIXED_PLANT_ASSET', 'D_RAW.SADB.TASK_PROCESS_TRKFCG_FIXED_PLANT_ASSET', 'GRPHC_OBJECT_VRSN_ID', 58),
    ('TRKFCG_FXPLA_TRACK_LCTN_DN', 'D_RAW.SADB.TRKFCG_FXPLA_TRACK_LCTN_DN_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRKFCG_FXPLA_TRACK_LCTN_DN', 'D_RAW.SADB.TASK_PROCESS_TRKFCG_FXPLA_TRACK_LCTN_DN', 'GRPHC_OBJECT_VRSN_ID', 62),
    ('TRKFCG_SBDVSN', 'D_RAW.SADB.TRKFCG_SBDVSN_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRKFCG_SBDVSN', 'D_RAW.SADB.TASK_PROCESS_TRKFCG_SBDVSN', 'GRPHC_OBJECT_VRSN_ID', 47),
    ('TRKFCG_SRVC_AREA', 'D_RAW.SADB.TRKFCG_SRVC_AREA_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRKFCG_SRVC_AREA', 'D_RAW.SADB.TASK_PROCESS_TRKFCG_SRVC_AREA', 'GRPHC_OBJECT_VRSN_ID', 25),
    ('TRKFCG_TRACK_SGMNT_DN', 'D_RAW.SADB.TRKFCG_TRACK_SGMNT_DN_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRKFCG_TRACK_SGMNT_DN', 'D_RAW.SADB.TASK_PROCESS_TRKFCG_TRACK_SGMNT_DN', 'GRPHC_OBJECT_VRSN_ID', 64),
    ('TRKFC_TRSTN', 'D_RAW.SADB.TRKFC_TRSTN_BASE_HIST_STREAM', 'D_RAW.SADB.SP_PROCESS_TRKFC_TRSTN', 'D_RAW.SADB.TASK_PROCESS_TRKFC_TRSTN', 'TRSTN_ID', 63);

-- ============================================================================
-- STEP 3: CREATE EXECUTION LOG TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS D_BRONZE.CDC_MONITORING.CDC_EXECUTION_LOG (
    LOG_ID NUMBER AUTOINCREMENT PRIMARY KEY,
    TABLE_NAME VARCHAR(100) NOT NULL,
    BATCH_ID VARCHAR(100),
    EXECUTION_START_TMS TIMESTAMP_NTZ NOT NULL,
    EXECUTION_END_TMS TIMESTAMP_NTZ,
    EXECUTION_STATUS VARCHAR(20) NOT NULL,
    ROWS_INSERTED NUMBER DEFAULT 0,
    ROWS_UPDATED NUMBER DEFAULT 0,
    ROWS_DELETED NUMBER DEFAULT 0,
    ROWS_PROCESSED NUMBER DEFAULT 0,
    ERROR_MESSAGE VARCHAR(4000),
    EXECUTION_DURATION_SEC NUMBER,
    SOURCE_STREAM_LAG_SEC NUMBER,
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ============================================================================
-- STEP 4: CREATE STREAM HEALTH SNAPSHOT TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS D_BRONZE.CDC_MONITORING.CDC_STREAM_HEALTH_SNAPSHOT (
    SNAPSHOT_ID NUMBER AUTOINCREMENT PRIMARY KEY,
    SNAPSHOT_TMS TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    TABLE_NAME VARCHAR(100) NOT NULL,
    STREAM_NAME VARCHAR(200) NOT NULL,
    IS_STALE BOOLEAN,
    STALE_AFTER TIMESTAMP_NTZ,
    HOURS_UNTIL_STALE NUMBER(10,2),
    HAS_PENDING_DATA BOOLEAN,
    STREAM_STATUS VARCHAR(20),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ============================================================================
-- STEP 5: CREATE TASK HEALTH SNAPSHOT TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT (
    SNAPSHOT_ID NUMBER AUTOINCREMENT PRIMARY KEY,
    SNAPSHOT_TMS TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    TABLE_NAME VARCHAR(100) NOT NULL,
    TASK_NAME VARCHAR(200) NOT NULL,
    TASK_STATE VARCHAR(20),
    LAST_RUN_TMS TIMESTAMP_NTZ,
    NEXT_SCHEDULED_TMS TIMESTAMP_NTZ,
    LAST_RUN_STATUS VARCHAR(20),
    LAST_RUN_DURATION_SEC NUMBER,
    MINUTES_SINCE_LAST_RUN NUMBER,
    IS_HEALTHY BOOLEAN,
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ============================================================================
-- STEP 6: CREATE DATA QUALITY METRICS TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS (
    METRIC_ID NUMBER AUTOINCREMENT PRIMARY KEY,
    SNAPSHOT_TMS TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    TABLE_NAME VARCHAR(100) NOT NULL,
    SOURCE_ROW_COUNT NUMBER,
    TARGET_ROW_COUNT NUMBER,
    ROW_COUNT_DIFF NUMBER,
    ROW_COUNT_MATCH_PCT NUMBER(5,2),
    DELETED_RECORDS_COUNT NUMBER,
    LATEST_SOURCE_UPDATE TIMESTAMP_NTZ,
    LATEST_TARGET_UPDATE TIMESTAMP_NTZ,
    UPDATE_LAG_MINUTES NUMBER,
    DATA_QUALITY_STATUS VARCHAR(20),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ============================================================================
-- STEP 7: CREATE ALERT LOG TABLE
-- ============================================================================
CREATE TABLE IF NOT EXISTS D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG (
    ALERT_ID NUMBER AUTOINCREMENT PRIMARY KEY,
    ALERT_TMS TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    ALERT_TYPE VARCHAR(50) NOT NULL,
    ALERT_SEVERITY VARCHAR(20) NOT NULL,
    TABLE_NAME VARCHAR(100),
    ALERT_MESSAGE VARCHAR(4000) NOT NULL,
    ALERT_DETAILS VARIANT,
    IS_ACKNOWLEDGED BOOLEAN DEFAULT FALSE,
    ACKNOWLEDGED_BY VARCHAR(100),
    ACKNOWLEDGED_TMS TIMESTAMP_NTZ,
    RESOLUTION_NOTES VARCHAR(4000),
    CREATED_AT TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

-- ============================================================================
-- STEP 8: CREATE STORED PROCEDURE - CAPTURE STREAM HEALTH
-- ============================================================================
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_CAPTURE_STREAM_HEALTH()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    v_result VARCHAR;
    v_snapshot_tms TIMESTAMP_NTZ := CURRENT_TIMESTAMP();
BEGIN
    -- Capture stream health for all configured streams
    INSERT INTO D_BRONZE.CDC_MONITORING.CDC_STREAM_HEALTH_SNAPSHOT 
        (SNAPSHOT_TMS, TABLE_NAME, STREAM_NAME, IS_STALE, STALE_AFTER, HOURS_UNTIL_STALE, HAS_PENDING_DATA, STREAM_STATUS)
    SELECT 
        :v_snapshot_tms,
        c.TABLE_NAME,
        c.STREAM_NAME,
        s.STALE,
        s.STALE_AFTER,
        TIMESTAMPDIFF(HOUR, CURRENT_TIMESTAMP(), s.STALE_AFTER),
        SYSTEM$STREAM_HAS_DATA(c.STREAM_NAME),
        CASE 
            WHEN s.STALE = TRUE THEN 'STALE'
            WHEN TIMESTAMPDIFF(HOUR, CURRENT_TIMESTAMP(), s.STALE_AFTER) < 24 THEN 'WARNING'
            ELSE 'HEALTHY'
        END
    FROM D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG c
    JOIN TABLE(RESULT_SCAN(LAST_QUERY_ID())) s
        ON TRUE
    WHERE c.IS_ACTIVE = TRUE;
    
    v_result := 'Stream health captured at ' || TO_VARCHAR(:v_snapshot_tms);
    RETURN v_result;
EXCEPTION
    WHEN OTHER THEN
        RETURN 'ERROR: ' || SQLERRM;
END;
$$;

-- ============================================================================
-- STEP 9: CREATE STORED PROCEDURE - CAPTURE TASK HEALTH
-- ============================================================================
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_CAPTURE_TASK_HEALTH()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    v_result VARCHAR;
    v_snapshot_tms TIMESTAMP_NTZ := CURRENT_TIMESTAMP();
BEGIN
    -- Capture task health from TASK_HISTORY
    INSERT INTO D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT 
        (SNAPSHOT_TMS, TABLE_NAME, TASK_NAME, TASK_STATE, LAST_RUN_TMS, LAST_RUN_STATUS, 
         LAST_RUN_DURATION_SEC, MINUTES_SINCE_LAST_RUN, IS_HEALTHY)
    SELECT 
        :v_snapshot_tms,
        c.TABLE_NAME,
        c.TASK_NAME,
        th.STATE,
        th.COMPLETED_TIME,
        th.STATE,
        TIMESTAMPDIFF(SECOND, th.SCHEDULED_TIME, th.COMPLETED_TIME),
        TIMESTAMPDIFF(MINUTE, th.COMPLETED_TIME, CURRENT_TIMESTAMP()),
        CASE 
            WHEN th.STATE = 'SUCCEEDED' AND TIMESTAMPDIFF(MINUTE, th.COMPLETED_TIME, CURRENT_TIMESTAMP()) < c.ALERT_THRESHOLD_MINUTES THEN TRUE
            ELSE FALSE
        END
    FROM D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG c
    LEFT JOIN (
        SELECT 
            NAME,
            STATE,
            SCHEDULED_TIME,
            COMPLETED_TIME,
            ROW_NUMBER() OVER (PARTITION BY NAME ORDER BY COMPLETED_TIME DESC) as RN
        FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(
            SCHEDULED_TIME_RANGE_START => DATEADD(HOUR, -24, CURRENT_TIMESTAMP()),
            RESULT_LIMIT => 1000
        ))
    ) th ON UPPER(c.TASK_NAME) = UPPER('D_RAW.SADB.' || th.NAME) AND th.RN = 1
    WHERE c.IS_ACTIVE = TRUE;
    
    v_result := 'Task health captured at ' || TO_VARCHAR(:v_snapshot_tms);
    RETURN v_result;
EXCEPTION
    WHEN OTHER THEN
        RETURN 'ERROR: ' || SQLERRM;
END;
$$;

-- ============================================================================
-- STEP 10: CREATE STORED PROCEDURE - CAPTURE DATA QUALITY METRICS
-- ============================================================================
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_CAPTURE_DATA_QUALITY_METRICS()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    v_result VARCHAR;
    v_snapshot_tms TIMESTAMP_NTZ := CURRENT_TIMESTAMP();
    v_table_name VARCHAR;
    v_source_count NUMBER;
    v_target_count NUMBER;
    v_deleted_count NUMBER;
    v_latest_source TIMESTAMP_NTZ;
    v_latest_target TIMESTAMP_NTZ;
    v_sql VARCHAR;
    c1 CURSOR FOR 
        SELECT TABLE_NAME 
        FROM D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG 
        WHERE IS_ACTIVE = TRUE;
BEGIN
    OPEN c1;
    FOR rec IN c1 DO
        v_table_name := rec.TABLE_NAME;
        
        -- Get source count
        v_sql := 'SELECT COUNT(*) FROM D_RAW.SADB.' || v_table_name || '_BASE';
        EXECUTE IMMEDIATE v_sql INTO v_source_count;
        
        -- Get target count and deleted count
        v_sql := 'SELECT COUNT(*), SUM(CASE WHEN IS_DELETED THEN 1 ELSE 0 END) FROM D_BRONZE.SADB.' || v_table_name;
        EXECUTE IMMEDIATE v_sql INTO v_target_count, v_deleted_count;
        
        -- Get latest update timestamps
        v_sql := 'SELECT MAX(SNW_LAST_REPLICATED) FROM D_RAW.SADB.' || v_table_name || '_BASE';
        EXECUTE IMMEDIATE v_sql INTO v_latest_source;
        
        v_sql := 'SELECT MAX(RECORD_UPDATED_AT) FROM D_BRONZE.SADB.' || v_table_name;
        EXECUTE IMMEDIATE v_sql INTO v_latest_target;
        
        -- Insert metrics
        INSERT INTO D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS (
            SNAPSHOT_TMS, TABLE_NAME, SOURCE_ROW_COUNT, TARGET_ROW_COUNT, 
            ROW_COUNT_DIFF, ROW_COUNT_MATCH_PCT, DELETED_RECORDS_COUNT,
            LATEST_SOURCE_UPDATE, LATEST_TARGET_UPDATE, UPDATE_LAG_MINUTES,
            DATA_QUALITY_STATUS
        )
        VALUES (
            :v_snapshot_tms,
            :v_table_name,
            :v_source_count,
            :v_target_count,
            :v_target_count - :v_source_count,
            CASE WHEN :v_source_count > 0 
                 THEN ROUND((:v_target_count - COALESCE(:v_deleted_count, 0)) / :v_source_count * 100, 2) 
                 ELSE 100 END,
            COALESCE(:v_deleted_count, 0),
            :v_latest_source,
            :v_latest_target,
            TIMESTAMPDIFF(MINUTE, :v_latest_source, :v_latest_target),
            CASE 
                WHEN ABS(:v_target_count - :v_source_count) <= 10 THEN 'HEALTHY'
                WHEN ABS(:v_target_count - :v_source_count) <= 100 THEN 'WARNING'
                ELSE 'CRITICAL'
            END
        );
    END FOR;
    CLOSE c1;
    
    v_result := 'Data quality metrics captured at ' || TO_VARCHAR(:v_snapshot_tms);
    RETURN v_result;
EXCEPTION
    WHEN OTHER THEN
        RETURN 'ERROR: ' || SQLERRM;
END;
$$;

-- ============================================================================
-- STEP 11: CREATE STORED PROCEDURE - GENERATE ALERTS
-- ============================================================================
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_GENERATE_ALERTS()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    v_result VARCHAR;
    v_alert_count NUMBER := 0;
BEGIN
    -- Alert: Stale Streams
    INSERT INTO D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG (ALERT_TYPE, ALERT_SEVERITY, TABLE_NAME, ALERT_MESSAGE, ALERT_DETAILS)
    SELECT 
        'STREAM_STALE',
        'CRITICAL',
        TABLE_NAME,
        'Stream ' || STREAM_NAME || ' is STALE for table ' || TABLE_NAME,
        OBJECT_CONSTRUCT('stream_name', STREAM_NAME, 'stale_after', STALE_AFTER, 'snapshot_tms', SNAPSHOT_TMS)
    FROM D_BRONZE.CDC_MONITORING.CDC_STREAM_HEALTH_SNAPSHOT
    WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_STREAM_HEALTH_SNAPSHOT)
      AND STREAM_STATUS = 'STALE'
      AND NOT EXISTS (
          SELECT 1 FROM D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG a
          WHERE a.ALERT_TYPE = 'STREAM_STALE'
            AND a.TABLE_NAME = CDC_STREAM_HEALTH_SNAPSHOT.TABLE_NAME
            AND a.IS_ACKNOWLEDGED = FALSE
            AND a.CREATED_AT > DATEADD(HOUR, -1, CURRENT_TIMESTAMP())
      );
    
    v_alert_count := v_alert_count + SQLROWCOUNT;
    
    -- Alert: Stream Warning (< 24 hours until stale)
    INSERT INTO D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG (ALERT_TYPE, ALERT_SEVERITY, TABLE_NAME, ALERT_MESSAGE, ALERT_DETAILS)
    SELECT 
        'STREAM_WARNING',
        'WARNING',
        TABLE_NAME,
        'Stream ' || STREAM_NAME || ' will become stale in ' || ROUND(HOURS_UNTIL_STALE, 1) || ' hours',
        OBJECT_CONSTRUCT('stream_name', STREAM_NAME, 'hours_until_stale', HOURS_UNTIL_STALE, 'stale_after', STALE_AFTER)
    FROM D_BRONZE.CDC_MONITORING.CDC_STREAM_HEALTH_SNAPSHOT
    WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_STREAM_HEALTH_SNAPSHOT)
      AND STREAM_STATUS = 'WARNING'
      AND NOT EXISTS (
          SELECT 1 FROM D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG a
          WHERE a.ALERT_TYPE = 'STREAM_WARNING'
            AND a.TABLE_NAME = CDC_STREAM_HEALTH_SNAPSHOT.TABLE_NAME
            AND a.IS_ACKNOWLEDGED = FALSE
            AND a.CREATED_AT > DATEADD(HOUR, -6, CURRENT_TIMESTAMP())
      );
    
    v_alert_count := v_alert_count + SQLROWCOUNT;
    
    -- Alert: Task Failures
    INSERT INTO D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG (ALERT_TYPE, ALERT_SEVERITY, TABLE_NAME, ALERT_MESSAGE, ALERT_DETAILS)
    SELECT 
        'TASK_FAILURE',
        'CRITICAL',
        TABLE_NAME,
        'Task ' || TASK_NAME || ' failed or is not healthy for table ' || TABLE_NAME,
        OBJECT_CONSTRUCT('task_name', TASK_NAME, 'task_state', TASK_STATE, 'last_run', LAST_RUN_TMS)
    FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT
    WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT)
      AND IS_HEALTHY = FALSE
      AND NOT EXISTS (
          SELECT 1 FROM D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG a
          WHERE a.ALERT_TYPE = 'TASK_FAILURE'
            AND a.TABLE_NAME = CDC_TASK_HEALTH_SNAPSHOT.TABLE_NAME
            AND a.IS_ACKNOWLEDGED = FALSE
            AND a.CREATED_AT > DATEADD(HOUR, -1, CURRENT_TIMESTAMP())
      );
    
    v_alert_count := v_alert_count + SQLROWCOUNT;
    
    -- Alert: Data Quality Issues
    INSERT INTO D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG (ALERT_TYPE, ALERT_SEVERITY, TABLE_NAME, ALERT_MESSAGE, ALERT_DETAILS)
    SELECT 
        'DATA_QUALITY',
        CASE WHEN DATA_QUALITY_STATUS = 'CRITICAL' THEN 'CRITICAL' ELSE 'WARNING' END,
        TABLE_NAME,
        'Data quality issue detected for ' || TABLE_NAME || ': Row count diff = ' || ROW_COUNT_DIFF,
        OBJECT_CONSTRUCT('source_count', SOURCE_ROW_COUNT, 'target_count', TARGET_ROW_COUNT, 
                         'diff', ROW_COUNT_DIFF, 'status', DATA_QUALITY_STATUS)
    FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS
    WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS)
      AND DATA_QUALITY_STATUS IN ('WARNING', 'CRITICAL')
      AND NOT EXISTS (
          SELECT 1 FROM D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG a
          WHERE a.ALERT_TYPE = 'DATA_QUALITY'
            AND a.TABLE_NAME = CDC_DATA_QUALITY_METRICS.TABLE_NAME
            AND a.IS_ACKNOWLEDGED = FALSE
            AND a.CREATED_AT > DATEADD(HOUR, -1, CURRENT_TIMESTAMP())
      );
    
    v_alert_count := v_alert_count + SQLROWCOUNT;
    
    RETURN 'Generated ' || v_alert_count || ' new alerts';
EXCEPTION
    WHEN OTHER THEN
        RETURN 'ERROR: ' || SQLERRM;
END;
$$;

-- ============================================================================
-- STEP 12: CREATE MASTER MONITORING PROCEDURE
-- ============================================================================
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_RUN_MONITORING_CYCLE()
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    v_result VARCHAR := '';
    v_step_result VARCHAR;
BEGIN
    -- Step 1: Capture Task Health
    CALL D_BRONZE.CDC_MONITORING.SP_CAPTURE_TASK_HEALTH() INTO v_step_result;
    v_result := v_result || 'Task Health: ' || v_step_result || '; ';
    
    -- Step 2: Capture Data Quality Metrics
    CALL D_BRONZE.CDC_MONITORING.SP_CAPTURE_DATA_QUALITY_METRICS() INTO v_step_result;
    v_result := v_result || 'Data Quality: ' || v_step_result || '; ';
    
    -- Step 3: Generate Alerts
    CALL D_BRONZE.CDC_MONITORING.SP_GENERATE_ALERTS() INTO v_step_result;
    v_result := v_result || 'Alerts: ' || v_step_result;
    
    RETURN v_result;
EXCEPTION
    WHEN OTHER THEN
        RETURN 'ERROR in monitoring cycle: ' || SQLERRM;
END;
$$;

-- ============================================================================
-- STEP 13: CREATE MONITORING TASK (RUNS EVERY 15 MINUTES)
-- ============================================================================
CREATE OR REPLACE TASK D_BRONZE.CDC_MONITORING.TASK_CDC_MONITORING_CYCLE
    WAREHOUSE = INFA_INGEST_WH
    SCHEDULE = '15 MINUTE'
    ALLOW_OVERLAPPING_EXECUTION = FALSE
    COMMENT = 'Master CDC monitoring task - captures health metrics and generates alerts'
AS
    CALL D_BRONZE.CDC_MONITORING.SP_RUN_MONITORING_CYCLE();

-- ============================================================================
-- STEP 14: CREATE OBSERVABILITY VIEWS
-- ============================================================================

-- View: Current Pipeline Health Dashboard
CREATE OR REPLACE VIEW D_BRONZE.CDC_MONITORING.VW_PIPELINE_HEALTH_DASHBOARD AS
SELECT 
    c.TABLE_NAME,
    c.SOURCE_SCHEMA || '.' || c.TABLE_NAME || '_BASE' AS SOURCE_TABLE,
    c.TARGET_SCHEMA || '.' || c.TABLE_NAME AS TARGET_TABLE,
    t.TASK_STATE,
    t.LAST_RUN_TMS,
    t.MINUTES_SINCE_LAST_RUN,
    t.IS_HEALTHY AS TASK_HEALTHY,
    dq.SOURCE_ROW_COUNT,
    dq.TARGET_ROW_COUNT,
    dq.ROW_COUNT_DIFF,
    dq.DELETED_RECORDS_COUNT,
    dq.DATA_QUALITY_STATUS,
    CASE 
        WHEN t.IS_HEALTHY = TRUE AND dq.DATA_QUALITY_STATUS = 'HEALTHY' THEN 'HEALTHY'
        WHEN t.IS_HEALTHY = FALSE OR dq.DATA_QUALITY_STATUS = 'CRITICAL' THEN 'CRITICAL'
        ELSE 'WARNING'
    END AS OVERALL_HEALTH
FROM D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG c
LEFT JOIN (
    SELECT * FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT
    WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT)
) t ON c.TABLE_NAME = t.TABLE_NAME
LEFT JOIN (
    SELECT * FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS
    WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS)
) dq ON c.TABLE_NAME = dq.TABLE_NAME
WHERE c.IS_ACTIVE = TRUE
ORDER BY 
    CASE WHEN t.IS_HEALTHY = FALSE OR dq.DATA_QUALITY_STATUS = 'CRITICAL' THEN 1
         WHEN dq.DATA_QUALITY_STATUS = 'WARNING' THEN 2
         ELSE 3 END,
    c.TABLE_NAME;

-- View: Active Alerts
CREATE OR REPLACE VIEW D_BRONZE.CDC_MONITORING.VW_ACTIVE_ALERTS AS
SELECT 
    ALERT_ID,
    ALERT_TMS,
    ALERT_TYPE,
    ALERT_SEVERITY,
    TABLE_NAME,
    ALERT_MESSAGE,
    ALERT_DETAILS,
    TIMESTAMPDIFF(MINUTE, ALERT_TMS, CURRENT_TIMESTAMP()) AS MINUTES_OPEN
FROM D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG
WHERE IS_ACKNOWLEDGED = FALSE
ORDER BY 
    CASE ALERT_SEVERITY WHEN 'CRITICAL' THEN 1 WHEN 'WARNING' THEN 2 ELSE 3 END,
    ALERT_TMS DESC;

-- View: Task Execution History (Last 24 Hours)
CREATE OR REPLACE VIEW D_BRONZE.CDC_MONITORING.VW_TASK_EXECUTION_HISTORY AS
SELECT 
    NAME AS TASK_NAME,
    STATE AS EXECUTION_STATUS,
    SCHEDULED_TIME,
    COMPLETED_TIME,
    TIMESTAMPDIFF(SECOND, SCHEDULED_TIME, COMPLETED_TIME) AS DURATION_SECONDS,
    ERROR_CODE,
    ERROR_MESSAGE
FROM TABLE(INFORMATION_SCHEMA.TASK_HISTORY(
    SCHEDULED_TIME_RANGE_START => DATEADD(HOUR, -24, CURRENT_TIMESTAMP()),
    RESULT_LIMIT => 1000
))
WHERE DATABASE_NAME = 'D_RAW' AND SCHEMA_NAME = 'SADB'
ORDER BY COMPLETED_TIME DESC;

-- View: Pipeline Trend Analysis (Last 7 Days)
CREATE OR REPLACE VIEW D_BRONZE.CDC_MONITORING.VW_PIPELINE_TREND_7D AS
SELECT 
    DATE(SNAPSHOT_TMS) AS METRIC_DATE,
    TABLE_NAME,
    AVG(SOURCE_ROW_COUNT) AS AVG_SOURCE_ROWS,
    AVG(TARGET_ROW_COUNT) AS AVG_TARGET_ROWS,
    AVG(ROW_COUNT_DIFF) AS AVG_ROW_DIFF,
    COUNT(CASE WHEN DATA_QUALITY_STATUS = 'HEALTHY' THEN 1 END) AS HEALTHY_SNAPSHOTS,
    COUNT(CASE WHEN DATA_QUALITY_STATUS = 'WARNING' THEN 1 END) AS WARNING_SNAPSHOTS,
    COUNT(CASE WHEN DATA_QUALITY_STATUS = 'CRITICAL' THEN 1 END) AS CRITICAL_SNAPSHOTS
FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS
WHERE SNAPSHOT_TMS >= DATEADD(DAY, -7, CURRENT_TIMESTAMP())
GROUP BY DATE(SNAPSHOT_TMS), TABLE_NAME
ORDER BY METRIC_DATE DESC, TABLE_NAME;

-- View: Pipeline Summary Statistics
CREATE OR REPLACE VIEW D_BRONZE.CDC_MONITORING.VW_PIPELINE_SUMMARY AS
SELECT 
    COUNT(*) AS TOTAL_PIPELINES,
    SUM(CASE WHEN c.IS_ACTIVE THEN 1 ELSE 0 END) AS ACTIVE_PIPELINES,
    SUM(CASE WHEN t.IS_HEALTHY = TRUE THEN 1 ELSE 0 END) AS HEALTHY_TASKS,
    SUM(CASE WHEN t.IS_HEALTHY = FALSE THEN 1 ELSE 0 END) AS UNHEALTHY_TASKS,
    SUM(CASE WHEN dq.DATA_QUALITY_STATUS = 'HEALTHY' THEN 1 ELSE 0 END) AS HEALTHY_DATA_QUALITY,
    SUM(CASE WHEN dq.DATA_QUALITY_STATUS = 'WARNING' THEN 1 ELSE 0 END) AS WARNING_DATA_QUALITY,
    SUM(CASE WHEN dq.DATA_QUALITY_STATUS = 'CRITICAL' THEN 1 ELSE 0 END) AS CRITICAL_DATA_QUALITY,
    SUM(dq.SOURCE_ROW_COUNT) AS TOTAL_SOURCE_ROWS,
    SUM(dq.TARGET_ROW_COUNT) AS TOTAL_TARGET_ROWS,
    (SELECT COUNT(*) FROM D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG WHERE IS_ACKNOWLEDGED = FALSE) AS OPEN_ALERTS
FROM D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG c
LEFT JOIN (
    SELECT * FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT
    WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT)
) t ON c.TABLE_NAME = t.TABLE_NAME
LEFT JOIN (
    SELECT * FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS
    WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS)
) dq ON c.TABLE_NAME = dq.TABLE_NAME;

-- View: CDC Operations Summary by Table
CREATE OR REPLACE VIEW D_BRONZE.CDC_MONITORING.VW_CDC_OPERATIONS_BY_TABLE AS
SELECT 
    c.TABLE_NAME,
    b.TOTAL_RECORDS,
    b.TOTAL_INSERTS,
    b.TOTAL_UPDATES,
    b.TOTAL_DELETES,
    b.ACTIVE_RECORDS,
    b.SOFT_DELETED_RECORDS,
    b.LATEST_CDC_TIMESTAMP,
    b.LATEST_BATCH_ID
FROM D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG c
CROSS JOIN LATERAL (
    SELECT 
        COUNT(*) AS TOTAL_RECORDS,
        SUM(CASE WHEN CDC_OPERATION = 'INSERT' THEN 1 ELSE 0 END) AS TOTAL_INSERTS,
        SUM(CASE WHEN CDC_OPERATION = 'UPDATE' THEN 1 ELSE 0 END) AS TOTAL_UPDATES,
        SUM(CASE WHEN CDC_OPERATION = 'DELETE' THEN 1 ELSE 0 END) AS TOTAL_DELETES,
        SUM(CASE WHEN IS_DELETED = FALSE THEN 1 ELSE 0 END) AS ACTIVE_RECORDS,
        SUM(CASE WHEN IS_DELETED = TRUE THEN 1 ELSE 0 END) AS SOFT_DELETED_RECORDS,
        MAX(CDC_TIMESTAMP) AS LATEST_CDC_TIMESTAMP,
        MAX(SOURCE_LOAD_BATCH_ID) AS LATEST_BATCH_ID
    FROM IDENTIFIER('D_BRONZE.SADB.' || c.TABLE_NAME)
) b
WHERE c.IS_ACTIVE = TRUE
ORDER BY c.TABLE_NAME;

-- ============================================================================
-- STEP 15: CREATE UTILITY PROCEDURES
-- ============================================================================

-- Procedure: Acknowledge Alert
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_ACKNOWLEDGE_ALERT(
    P_ALERT_ID NUMBER,
    P_ACKNOWLEDGED_BY VARCHAR,
    P_RESOLUTION_NOTES VARCHAR DEFAULT NULL
)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
BEGIN
    UPDATE D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG
    SET IS_ACKNOWLEDGED = TRUE,
        ACKNOWLEDGED_BY = P_ACKNOWLEDGED_BY,
        ACKNOWLEDGED_TMS = CURRENT_TIMESTAMP(),
        RESOLUTION_NOTES = P_RESOLUTION_NOTES
    WHERE ALERT_ID = P_ALERT_ID;
    
    IF (SQLROWCOUNT > 0) THEN
        RETURN 'Alert ' || P_ALERT_ID || ' acknowledged by ' || P_ACKNOWLEDGED_BY;
    ELSE
        RETURN 'Alert ' || P_ALERT_ID || ' not found';
    END IF;
EXCEPTION
    WHEN OTHER THEN
        RETURN 'ERROR: ' || SQLERRM;
END;
$$;

-- Procedure: Acknowledge All Alerts for Table
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_ACKNOWLEDGE_ALL_ALERTS_FOR_TABLE(
    P_TABLE_NAME VARCHAR,
    P_ACKNOWLEDGED_BY VARCHAR,
    P_RESOLUTION_NOTES VARCHAR DEFAULT NULL
)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    v_count NUMBER;
BEGIN
    UPDATE D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG
    SET IS_ACKNOWLEDGED = TRUE,
        ACKNOWLEDGED_BY = P_ACKNOWLEDGED_BY,
        ACKNOWLEDGED_TMS = CURRENT_TIMESTAMP(),
        RESOLUTION_NOTES = P_RESOLUTION_NOTES
    WHERE TABLE_NAME = P_TABLE_NAME
      AND IS_ACKNOWLEDGED = FALSE;
    
    v_count := SQLROWCOUNT;
    RETURN 'Acknowledged ' || v_count || ' alerts for table ' || P_TABLE_NAME;
EXCEPTION
    WHEN OTHER THEN
        RETURN 'ERROR: ' || SQLERRM;
END;
$$;

-- Procedure: Get Pipeline Status Report
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_GET_PIPELINE_STATUS_REPORT()
RETURNS TABLE (
    TABLE_NAME VARCHAR,
    TASK_STATUS VARCHAR,
    DATA_QUALITY_STATUS VARCHAR,
    SOURCE_ROWS NUMBER,
    TARGET_ROWS NUMBER,
    OPEN_ALERTS NUMBER,
    LAST_EXECUTION TIMESTAMP_NTZ
)
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    res RESULTSET;
BEGIN
    res := (
        SELECT 
            c.TABLE_NAME,
            COALESCE(t.TASK_STATE, 'UNKNOWN') AS TASK_STATUS,
            COALESCE(dq.DATA_QUALITY_STATUS, 'UNKNOWN') AS DATA_QUALITY_STATUS,
            COALESCE(dq.SOURCE_ROW_COUNT, 0) AS SOURCE_ROWS,
            COALESCE(dq.TARGET_ROW_COUNT, 0) AS TARGET_ROWS,
            COALESCE(a.ALERT_COUNT, 0) AS OPEN_ALERTS,
            t.LAST_RUN_TMS AS LAST_EXECUTION
        FROM D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG c
        LEFT JOIN (
            SELECT * FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT
            WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT)
        ) t ON c.TABLE_NAME = t.TABLE_NAME
        LEFT JOIN (
            SELECT * FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS
            WHERE SNAPSHOT_TMS = (SELECT MAX(SNAPSHOT_TMS) FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS)
        ) dq ON c.TABLE_NAME = dq.TABLE_NAME
        LEFT JOIN (
            SELECT TABLE_NAME, COUNT(*) AS ALERT_COUNT
            FROM D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG
            WHERE IS_ACKNOWLEDGED = FALSE
            GROUP BY TABLE_NAME
        ) a ON c.TABLE_NAME = a.TABLE_NAME
        WHERE c.IS_ACTIVE = TRUE
        ORDER BY c.TABLE_NAME
    );
    RETURN TABLE(res);
END;
$$;

-- ============================================================================
-- STEP 16: CREATE DATA RETENTION PROCEDURE
-- ============================================================================
CREATE OR REPLACE PROCEDURE D_BRONZE.CDC_MONITORING.SP_CLEANUP_OLD_MONITORING_DATA(
    P_RETENTION_DAYS NUMBER DEFAULT 90
)
RETURNS VARCHAR
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
    v_cutoff_date TIMESTAMP_NTZ;
    v_deleted_stream NUMBER := 0;
    v_deleted_task NUMBER := 0;
    v_deleted_quality NUMBER := 0;
    v_deleted_alerts NUMBER := 0;
BEGIN
    v_cutoff_date := DATEADD(DAY, -P_RETENTION_DAYS, CURRENT_TIMESTAMP());
    
    DELETE FROM D_BRONZE.CDC_MONITORING.CDC_STREAM_HEALTH_SNAPSHOT WHERE CREATED_AT < :v_cutoff_date;
    v_deleted_stream := SQLROWCOUNT;
    
    DELETE FROM D_BRONZE.CDC_MONITORING.CDC_TASK_HEALTH_SNAPSHOT WHERE CREATED_AT < :v_cutoff_date;
    v_deleted_task := SQLROWCOUNT;
    
    DELETE FROM D_BRONZE.CDC_MONITORING.CDC_DATA_QUALITY_METRICS WHERE CREATED_AT < :v_cutoff_date;
    v_deleted_quality := SQLROWCOUNT;
    
    DELETE FROM D_BRONZE.CDC_MONITORING.CDC_ALERT_LOG WHERE CREATED_AT < :v_cutoff_date AND IS_ACKNOWLEDGED = TRUE;
    v_deleted_alerts := SQLROWCOUNT;
    
    RETURN 'Cleanup completed. Deleted: Stream=' || v_deleted_stream || 
           ', Task=' || v_deleted_task || 
           ', Quality=' || v_deleted_quality || 
           ', Alerts=' || v_deleted_alerts;
EXCEPTION
    WHEN OTHER THEN
        RETURN 'ERROR: ' || SQLERRM;
END;
$$;

-- ============================================================================
-- STEP 17: CREATE CLEANUP TASK (RUNS WEEKLY)
-- ============================================================================
CREATE OR REPLACE TASK D_BRONZE.CDC_MONITORING.TASK_CDC_MONITORING_CLEANUP
    WAREHOUSE = INFA_INGEST_WH
    SCHEDULE = 'USING CRON 0 2 * * SUN America/Chicago'
    ALLOW_OVERLAPPING_EXECUTION = FALSE
    COMMENT = 'Weekly cleanup of old monitoring data (90 day retention)'
AS
    CALL D_BRONZE.CDC_MONITORING.SP_CLEANUP_OLD_MONITORING_DATA(90);

-- ============================================================================
-- STEP 18: RESUME MONITORING TASKS
-- ============================================================================
ALTER TASK D_BRONZE.CDC_MONITORING.TASK_CDC_MONITORING_CYCLE RESUME;
ALTER TASK D_BRONZE.CDC_MONITORING.TASK_CDC_MONITORING_CLEANUP RESUME;

-- ============================================================================
-- STEP 19: RUN INITIAL MONITORING CYCLE
-- ============================================================================
CALL D_BRONZE.CDC_MONITORING.SP_RUN_MONITORING_CYCLE();

-- ============================================================================
-- STEP 20: GRANT PERMISSIONS
-- ============================================================================
GRANT USAGE ON SCHEMA D_BRONZE.CDC_MONITORING TO ROLE PUBLIC;
GRANT SELECT ON ALL VIEWS IN SCHEMA D_BRONZE.CDC_MONITORING TO ROLE PUBLIC;
GRANT SELECT ON ALL TABLES IN SCHEMA D_BRONZE.CDC_MONITORING TO ROLE PUBLIC;

-- ============================================================================
-- VERIFICATION QUERIES
-- ============================================================================
-- Check monitoring configuration
SELECT * FROM D_BRONZE.CDC_MONITORING.CDC_PIPELINE_CONFIG ORDER BY TABLE_NAME;

-- Check pipeline health dashboard
SELECT * FROM D_BRONZE.CDC_MONITORING.VW_PIPELINE_HEALTH_DASHBOARD;

-- Check active alerts
SELECT * FROM D_BRONZE.CDC_MONITORING.VW_ACTIVE_ALERTS;

-- Check pipeline summary
SELECT * FROM D_BRONZE.CDC_MONITORING.VW_PIPELINE_SUMMARY;
